/* Autogenerated file. Do not edit manually. */

/* tslint:disable */

/* eslint-disable */
import type { EventFragment, FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";

import type { OnEvent, PromiseOrValue, TypedEvent, TypedEventFilter, TypedListener } from "../../common";

export interface RiskManagerInterface extends utils.Interface {
  functions: {
    "IS_RISK_MANAGER()": FunctionFragment;
    "_borrowGuardianPaused()": FunctionFragment;
    "_supplyGuardianPaused()": FunctionFragment;
    "acceptAdmin()": FunctionFragment;
    "admin()": FunctionFragment;
    "borrowAllowed(address,address,uint256)": FunctionFragment;
    "borrowGuardianPaused(address)": FunctionFragment;
    "checkListed(address)": FunctionFragment;
    "checkMembership(address,address)": FunctionFragment;
    "closeFactorMantissa()": FunctionFragment;
    "closeLiquidation(address)": FunctionFragment;
    "collateralFactorBoost(address)": FunctionFragment;
    "enterMarkets(address[])": FunctionFragment;
    "exitMarket(address)": FunctionFragment;
    "getAccountLiquidity(address)": FunctionFragment;
    "getHypotheticalAccountLiquidity(address,address,uint256,uint256)": FunctionFragment;
    "getMarketsEntered(address)": FunctionFragment;
    "initialize(address)": FunctionFragment;
    "initiateLiquidation(address)": FunctionFragment;
    "isRiskManager()": FunctionFragment;
    "liquidatableTime(address)": FunctionFragment;
    "liquidateBorrowAllowed(address,address,address,uint256)": FunctionFragment;
    "liquidateCalculateDiscount(address)": FunctionFragment;
    "liquidateCalculateSeizeTokens(address,address,address,uint256)": FunctionFragment;
    "markets(address)": FunctionFragment;
    "marketsEntered(address,uint256)": FunctionFragment;
    "oracle()": FunctionFragment;
    "pauseGuardian()": FunctionFragment;
    "pendingAdmin()": FunctionFragment;
    "redeemAllowed(address,address,uint256)": FunctionFragment;
    "repayBorrowAllowed(address)": FunctionFragment;
    "seizeAllowed(address,address,address,uint256)": FunctionFragment;
    "seizeGuardianPaused()": FunctionFragment;
    "setBorrowPaused(address,bool)": FunctionFragment;
    "setCloseFactor(uint256)": FunctionFragment;
    "setCollateralFactor(address,uint256)": FunctionFragment;
    "setPendingAdmin(address)": FunctionFragment;
    "setPriceOracle(address)": FunctionFragment;
    "setSeizePaused(bool)": FunctionFragment;
    "setSupplyPaused(address,bool)": FunctionFragment;
    "setTier(address,uint256)": FunctionFragment;
    "setTransferPaused(bool)": FunctionFragment;
    "setVeToken(address)": FunctionFragment;
    "supplyAllowed(address)": FunctionFragment;
    "supplyGuardianPaused(address)": FunctionFragment;
    "supportMarket(address,uint256,uint256)": FunctionFragment;
    "transferAllowed(address,address,uint256)": FunctionFragment;
    "transferGuardianPaused()": FunctionFragment;
    "veToken()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "IS_RISK_MANAGER"
      | "_borrowGuardianPaused"
      | "_supplyGuardianPaused"
      | "acceptAdmin"
      | "admin"
      | "borrowAllowed"
      | "borrowGuardianPaused"
      | "checkListed"
      | "checkMembership"
      | "closeFactorMantissa"
      | "closeLiquidation"
      | "collateralFactorBoost"
      | "enterMarkets"
      | "exitMarket"
      | "getAccountLiquidity"
      | "getHypotheticalAccountLiquidity"
      | "getMarketsEntered"
      | "initialize"
      | "initiateLiquidation"
      | "isRiskManager"
      | "liquidatableTime"
      | "liquidateBorrowAllowed"
      | "liquidateCalculateDiscount"
      | "liquidateCalculateSeizeTokens"
      | "markets"
      | "marketsEntered"
      | "oracle"
      | "pauseGuardian"
      | "pendingAdmin"
      | "redeemAllowed"
      | "repayBorrowAllowed"
      | "seizeAllowed"
      | "seizeGuardianPaused"
      | "setBorrowPaused"
      | "setCloseFactor"
      | "setCollateralFactor"
      | "setPendingAdmin"
      | "setPriceOracle"
      | "setSeizePaused"
      | "setSupplyPaused"
      | "setTier"
      | "setTransferPaused"
      | "setVeToken"
      | "supplyAllowed"
      | "supplyGuardianPaused"
      | "supportMarket"
      | "transferAllowed"
      | "transferGuardianPaused"
      | "veToken",
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "IS_RISK_MANAGER", values?: undefined): string;
  encodeFunctionData(functionFragment: "_borrowGuardianPaused", values?: undefined): string;
  encodeFunctionData(functionFragment: "_supplyGuardianPaused", values?: undefined): string;
  encodeFunctionData(functionFragment: "acceptAdmin", values?: undefined): string;
  encodeFunctionData(functionFragment: "admin", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "borrowAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "borrowGuardianPaused", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "checkListed", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: "checkMembership",
    values: [PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(functionFragment: "closeFactorMantissa", values?: undefined): string;
  encodeFunctionData(functionFragment: "closeLiquidation", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "collateralFactorBoost", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "enterMarkets", values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: "exitMarket", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "getAccountLiquidity", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: "getHypotheticalAccountLiquidity",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(functionFragment: "getMarketsEntered", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "initialize", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "initiateLiquidation", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "isRiskManager", values?: undefined): string;
  encodeFunctionData(functionFragment: "liquidatableTime", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: "liquidateBorrowAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "liquidateCalculateDiscount", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: "liquidateCalculateSeizeTokens",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "markets", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: "marketsEntered",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "oracle", values?: undefined): string;
  encodeFunctionData(functionFragment: "pauseGuardian", values?: undefined): string;
  encodeFunctionData(functionFragment: "pendingAdmin", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "redeemAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "repayBorrowAllowed", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: "seizeAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "seizeGuardianPaused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setBorrowPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(functionFragment: "setCloseFactor", values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: "setCollateralFactor",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "setPendingAdmin", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "setPriceOracle", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "setSeizePaused", values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(
    functionFragment: "setSupplyPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: "setTier",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "setTransferPaused", values: [PromiseOrValue<boolean>]): string;
  encodeFunctionData(functionFragment: "setVeToken", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "supplyAllowed", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "supplyGuardianPaused", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: "supportMarket",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: "transferAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "transferGuardianPaused", values?: undefined): string;
  encodeFunctionData(functionFragment: "veToken", values?: undefined): string;

  decodeFunctionResult(functionFragment: "IS_RISK_MANAGER", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_borrowGuardianPaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_supplyGuardianPaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "acceptAdmin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "admin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "borrowAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "borrowGuardianPaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "checkListed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "checkMembership", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "closeFactorMantissa", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "closeLiquidation", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "collateralFactorBoost", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "enterMarkets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "exitMarket", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getAccountLiquidity", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getHypotheticalAccountLiquidity", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMarketsEntered", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initiateLiquidation", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isRiskManager", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liquidatableTime", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liquidateBorrowAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liquidateCalculateDiscount", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liquidateCalculateSeizeTokens", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "markets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "marketsEntered", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "oracle", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pauseGuardian", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pendingAdmin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "redeemAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "repayBorrowAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "seizeAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "seizeGuardianPaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setBorrowPaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setCloseFactor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setCollateralFactor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setPendingAdmin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setPriceOracle", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setSeizePaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setSupplyPaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setTier", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setTransferPaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setVeToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "supplyAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "supplyGuardianPaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "supportMarket", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "transferAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "transferGuardianPaused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "veToken", data: BytesLike): Result;

  events: {
    "ActionPausedGlobal(string,bool)": EventFragment;
    "ActionPausedMarket(address,string,bool)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "MarketEntered(address,address)": EventFragment;
    "MarketExited(address,address)": EventFragment;
    "MarketListed(address)": EventFragment;
    "NewAdmin(address,address)": EventFragment;
    "NewCloseFactor(uint256,uint256)": EventFragment;
    "NewCollateralFactor(address,uint256,uint256)": EventFragment;
    "NewPendingAdmin(address,address)": EventFragment;
    "NewPriceOracle(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ActionPausedGlobal"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ActionPausedMarket"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarketEntered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarketExited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarketListed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewAdmin"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewCloseFactor"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewCollateralFactor"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewPendingAdmin"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewPriceOracle"): EventFragment;
}

export interface ActionPausedGlobalEventObject {
  action: string;
  pauseState: boolean;
}
export type ActionPausedGlobalEvent = TypedEvent<[string, boolean], ActionPausedGlobalEventObject>;

export type ActionPausedGlobalEventFilter = TypedEventFilter<ActionPausedGlobalEvent>;

export interface ActionPausedMarketEventObject {
  fToken: string;
  action: string;
  pauseState: boolean;
}
export type ActionPausedMarketEvent = TypedEvent<[string, string, boolean], ActionPausedMarketEventObject>;

export type ActionPausedMarketEventFilter = TypedEventFilter<ActionPausedMarketEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface MarketEnteredEventObject {
  fToken: string;
  account: string;
}
export type MarketEnteredEvent = TypedEvent<[string, string], MarketEnteredEventObject>;

export type MarketEnteredEventFilter = TypedEventFilter<MarketEnteredEvent>;

export interface MarketExitedEventObject {
  fToken: string;
  account: string;
}
export type MarketExitedEvent = TypedEvent<[string, string], MarketExitedEventObject>;

export type MarketExitedEventFilter = TypedEventFilter<MarketExitedEvent>;

export interface MarketListedEventObject {
  fToken: string;
}
export type MarketListedEvent = TypedEvent<[string], MarketListedEventObject>;

export type MarketListedEventFilter = TypedEventFilter<MarketListedEvent>;

export interface NewAdminEventObject {
  oldAdmin: string;
  newAdmin: string;
}
export type NewAdminEvent = TypedEvent<[string, string], NewAdminEventObject>;

export type NewAdminEventFilter = TypedEventFilter<NewAdminEvent>;

export interface NewCloseFactorEventObject {
  oldCloseFactorMantissa: BigNumber;
  newCloseFactorMantissa: BigNumber;
}
export type NewCloseFactorEvent = TypedEvent<[BigNumber, BigNumber], NewCloseFactorEventObject>;

export type NewCloseFactorEventFilter = TypedEventFilter<NewCloseFactorEvent>;

export interface NewCollateralFactorEventObject {
  fToken: string;
  oldCollateralFactorMantissa: BigNumber;
  newCollateralFactorMantissa: BigNumber;
}
export type NewCollateralFactorEvent = TypedEvent<[string, BigNumber, BigNumber], NewCollateralFactorEventObject>;

export type NewCollateralFactorEventFilter = TypedEventFilter<NewCollateralFactorEvent>;

export interface NewPendingAdminEventObject {
  oldPendingAdmin: string;
  newPendingAdmin: string;
}
export type NewPendingAdminEvent = TypedEvent<[string, string], NewPendingAdminEventObject>;

export type NewPendingAdminEventFilter = TypedEventFilter<NewPendingAdminEvent>;

export interface NewPriceOracleEventObject {
  oldPriceOracle: string;
  newPriceOracle: string;
}
export type NewPriceOracleEvent = TypedEvent<[string, string], NewPriceOracleEventObject>;

export type NewPriceOracleEventFilter = TypedEventFilter<NewPriceOracleEvent>;

export interface RiskManager extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: RiskManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    IS_RISK_MANAGER(overrides?: CallOverrides): Promise<[boolean]>;

    _borrowGuardianPaused(overrides?: CallOverrides): Promise<[boolean]>;

    _supplyGuardianPaused(overrides?: CallOverrides): Promise<[boolean]>;

    acceptAdmin(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    admin(overrides?: CallOverrides): Promise<[string]>;

    borrowAllowed(
      _fToken: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    borrowGuardianPaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    checkListed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    checkMembership(
      _account: PromiseOrValue<string>,
      _fToken: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    closeFactorMantissa(overrides?: CallOverrides): Promise<[BigNumber]>;

    closeLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    collateralFactorBoost(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { boostMantissa: BigNumber }>;

    enterMarkets(
      _fTokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exitMarket(
      _fToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getAccountLiquidity(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber[], BigNumber, BigNumber] & {
        liquidities: BigNumber[];
        shortfall: BigNumber;
        highestBorrowTier: BigNumber;
      }
    >;

    getHypotheticalAccountLiquidity(
      _account: PromiseOrValue<string>,
      _fToken: PromiseOrValue<string>,
      _redeemToken: PromiseOrValue<BigNumberish>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber[], BigNumber, BigNumber] & {
        liquidities: BigNumber[];
        shortfall: BigNumber;
        highestBorrowTier: BigNumber;
      }
    >;

    getMarketsEntered(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string[]]>;

    initialize(
      _priceOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    initiateLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isRiskManager(overrides?: CallOverrides): Promise<[boolean]>;

    liquidatableTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;

    liquidateBorrowAllowed(
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    liquidateCalculateDiscount(
      _borrower: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { discountMantissa: BigNumber }>;

    liquidateCalculateSeizeTokens(
      _borrower: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { seizeTokens: BigNumber; repayValue: BigNumber }>;

    markets(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, BigNumber, BigNumber] & {
        isListed: boolean;
        collateralFactorMantissa: BigNumber;
        tier: BigNumber;
      }
    >;

    marketsEntered(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    oracle(overrides?: CallOverrides): Promise<[string]>;

    pauseGuardian(overrides?: CallOverrides): Promise<[string]>;

    pendingAdmin(overrides?: CallOverrides): Promise<[string]>;

    redeemAllowed(
      _fToken: PromiseOrValue<string>,
      _redeemer: PromiseOrValue<string>,
      _redeemTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    repayBorrowAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    seizeAllowed(
      _fTokenCollateral: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _seizeTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean, boolean] & { allowed: boolean; isCollateralTier: boolean }>;

    seizeGuardianPaused(overrides?: CallOverrides): Promise<[boolean]>;

    setBorrowPaused(
      _fToken: PromiseOrValue<string>,
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setCloseFactor(
      _newCloseFactorMantissa: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setCollateralFactor(
      _fToken: PromiseOrValue<string>,
      _newCollateralFactorMantissa: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPendingAdmin(
      _newPendingAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setPriceOracle(
      _newOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setSeizePaused(
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setSupplyPaused(
      _fToken: PromiseOrValue<string>,
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setTier(
      _fToken: PromiseOrValue<string>,
      _tier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setTransferPaused(
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setVeToken(
      _newVetoken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    supplyAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    supplyGuardianPaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    supportMarket(
      _fToken: PromiseOrValue<string>,
      _collateralFactorMantissa: PromiseOrValue<BigNumberish>,
      _tier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    transferAllowed(
      _fToken: PromiseOrValue<string>,
      _src: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    transferGuardianPaused(overrides?: CallOverrides): Promise<[boolean]>;

    veToken(overrides?: CallOverrides): Promise<[string]>;
  };

  IS_RISK_MANAGER(overrides?: CallOverrides): Promise<boolean>;

  _borrowGuardianPaused(overrides?: CallOverrides): Promise<boolean>;

  _supplyGuardianPaused(overrides?: CallOverrides): Promise<boolean>;

  acceptAdmin(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  admin(overrides?: CallOverrides): Promise<string>;

  borrowAllowed(
    _fToken: PromiseOrValue<string>,
    _borrower: PromiseOrValue<string>,
    _borrowAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  borrowGuardianPaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  checkListed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  checkMembership(
    _account: PromiseOrValue<string>,
    _fToken: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  closeFactorMantissa(overrides?: CallOverrides): Promise<BigNumber>;

  closeLiquidation(
    _account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  collateralFactorBoost(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  enterMarkets(
    _fTokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exitMarket(
    _fToken: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getAccountLiquidity(
    _account: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber[], BigNumber, BigNumber] & {
      liquidities: BigNumber[];
      shortfall: BigNumber;
      highestBorrowTier: BigNumber;
    }
  >;

  getHypotheticalAccountLiquidity(
    _account: PromiseOrValue<string>,
    _fToken: PromiseOrValue<string>,
    _redeemToken: PromiseOrValue<BigNumberish>,
    _borrowAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<
    [BigNumber[], BigNumber, BigNumber] & {
      liquidities: BigNumber[];
      shortfall: BigNumber;
      highestBorrowTier: BigNumber;
    }
  >;

  getMarketsEntered(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

  initialize(
    _priceOracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  initiateLiquidation(
    _account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isRiskManager(overrides?: CallOverrides): Promise<boolean>;

  liquidatableTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  liquidateBorrowAllowed(
    _fTokenBorrowed: PromiseOrValue<string>,
    _fTokenCollateral: PromiseOrValue<string>,
    _borrower: PromiseOrValue<string>,
    _repayAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  liquidateCalculateDiscount(_borrower: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

  liquidateCalculateSeizeTokens(
    _borrower: PromiseOrValue<string>,
    _fTokenBorrowed: PromiseOrValue<string>,
    _fTokenCollateral: PromiseOrValue<string>,
    _repayAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { seizeTokens: BigNumber; repayValue: BigNumber }>;

  markets(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<
    [boolean, BigNumber, BigNumber] & {
      isListed: boolean;
      collateralFactorMantissa: BigNumber;
      tier: BigNumber;
    }
  >;

  marketsEntered(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<string>;

  oracle(overrides?: CallOverrides): Promise<string>;

  pauseGuardian(overrides?: CallOverrides): Promise<string>;

  pendingAdmin(overrides?: CallOverrides): Promise<string>;

  redeemAllowed(
    _fToken: PromiseOrValue<string>,
    _redeemer: PromiseOrValue<string>,
    _redeemTokens: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  repayBorrowAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  seizeAllowed(
    _fTokenCollateral: PromiseOrValue<string>,
    _fTokenBorrowed: PromiseOrValue<string>,
    _borrower: PromiseOrValue<string>,
    _seizeTokens: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[boolean, boolean] & { allowed: boolean; isCollateralTier: boolean }>;

  seizeGuardianPaused(overrides?: CallOverrides): Promise<boolean>;

  setBorrowPaused(
    _fToken: PromiseOrValue<string>,
    _state: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setCloseFactor(
    _newCloseFactorMantissa: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setCollateralFactor(
    _fToken: PromiseOrValue<string>,
    _newCollateralFactorMantissa: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPendingAdmin(
    _newPendingAdmin: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setPriceOracle(
    _newOracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setSeizePaused(
    _state: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setSupplyPaused(
    _fToken: PromiseOrValue<string>,
    _state: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setTier(
    _fToken: PromiseOrValue<string>,
    _tier: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setTransferPaused(
    _state: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setVeToken(
    _newVetoken: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  supplyAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  supplyGuardianPaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  supportMarket(
    _fToken: PromiseOrValue<string>,
    _collateralFactorMantissa: PromiseOrValue<BigNumberish>,
    _tier: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  transferAllowed(
    _fToken: PromiseOrValue<string>,
    _src: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  transferGuardianPaused(overrides?: CallOverrides): Promise<boolean>;

  veToken(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    IS_RISK_MANAGER(overrides?: CallOverrides): Promise<boolean>;

    _borrowGuardianPaused(overrides?: CallOverrides): Promise<boolean>;

    _supplyGuardianPaused(overrides?: CallOverrides): Promise<boolean>;

    acceptAdmin(overrides?: CallOverrides): Promise<void>;

    admin(overrides?: CallOverrides): Promise<string>;

    borrowAllowed(
      _fToken: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    borrowGuardianPaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    checkListed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    checkMembership(
      _account: PromiseOrValue<string>,
      _fToken: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    closeFactorMantissa(overrides?: CallOverrides): Promise<BigNumber>;

    closeLiquidation(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    collateralFactorBoost(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    enterMarkets(_fTokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    exitMarket(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    getAccountLiquidity(
      _account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber[], BigNumber, BigNumber] & {
        liquidities: BigNumber[];
        shortfall: BigNumber;
        highestBorrowTier: BigNumber;
      }
    >;

    getHypotheticalAccountLiquidity(
      _account: PromiseOrValue<string>,
      _fToken: PromiseOrValue<string>,
      _redeemToken: PromiseOrValue<BigNumberish>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<
      [BigNumber[], BigNumber, BigNumber] & {
        liquidities: BigNumber[];
        shortfall: BigNumber;
        highestBorrowTier: BigNumber;
      }
    >;

    getMarketsEntered(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

    initialize(_priceOracle: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    initiateLiquidation(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    isRiskManager(overrides?: CallOverrides): Promise<boolean>;

    liquidatableTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    liquidateBorrowAllowed(
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    liquidateCalculateDiscount(_borrower: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    liquidateCalculateSeizeTokens(
      _borrower: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { seizeTokens: BigNumber; repayValue: BigNumber }>;

    markets(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<
      [boolean, BigNumber, BigNumber] & {
        isListed: boolean;
        collateralFactorMantissa: BigNumber;
        tier: BigNumber;
      }
    >;

    marketsEntered(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<string>;

    oracle(overrides?: CallOverrides): Promise<string>;

    pauseGuardian(overrides?: CallOverrides): Promise<string>;

    pendingAdmin(overrides?: CallOverrides): Promise<string>;

    redeemAllowed(
      _fToken: PromiseOrValue<string>,
      _redeemer: PromiseOrValue<string>,
      _redeemTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    repayBorrowAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    seizeAllowed(
      _fTokenCollateral: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _seizeTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean, boolean] & { allowed: boolean; isCollateralTier: boolean }>;

    seizeGuardianPaused(overrides?: CallOverrides): Promise<boolean>;

    setBorrowPaused(
      _fToken: PromiseOrValue<string>,
      _state: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    setCloseFactor(_newCloseFactorMantissa: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    setCollateralFactor(
      _fToken: PromiseOrValue<string>,
      _newCollateralFactorMantissa: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setPendingAdmin(_newPendingAdmin: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setPriceOracle(_newOracle: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    setSeizePaused(_state: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<boolean>;

    setSupplyPaused(
      _fToken: PromiseOrValue<string>,
      _state: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    setTier(
      _fToken: PromiseOrValue<string>,
      _tier: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setTransferPaused(_state: PromiseOrValue<boolean>, overrides?: CallOverrides): Promise<boolean>;

    setVeToken(_newVetoken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    supplyAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    supplyGuardianPaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    supportMarket(
      _fToken: PromiseOrValue<string>,
      _collateralFactorMantissa: PromiseOrValue<BigNumberish>,
      _tier: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    transferAllowed(
      _fToken: PromiseOrValue<string>,
      _src: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    transferGuardianPaused(overrides?: CallOverrides): Promise<boolean>;

    veToken(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "ActionPausedGlobal(string,bool)"(action?: null, pauseState?: null): ActionPausedGlobalEventFilter;
    ActionPausedGlobal(action?: null, pauseState?: null): ActionPausedGlobalEventFilter;

    "ActionPausedMarket(address,string,bool)"(
      fToken?: null,
      action?: null,
      pauseState?: null,
    ): ActionPausedMarketEventFilter;
    ActionPausedMarket(fToken?: null, action?: null, pauseState?: null): ActionPausedMarketEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "MarketEntered(address,address)"(fToken?: null, account?: null): MarketEnteredEventFilter;
    MarketEntered(fToken?: null, account?: null): MarketEnteredEventFilter;

    "MarketExited(address,address)"(fToken?: null, account?: null): MarketExitedEventFilter;
    MarketExited(fToken?: null, account?: null): MarketExitedEventFilter;

    "MarketListed(address)"(fToken?: null): MarketListedEventFilter;
    MarketListed(fToken?: null): MarketListedEventFilter;

    "NewAdmin(address,address)"(oldAdmin?: null, newAdmin?: null): NewAdminEventFilter;
    NewAdmin(oldAdmin?: null, newAdmin?: null): NewAdminEventFilter;

    "NewCloseFactor(uint256,uint256)"(
      oldCloseFactorMantissa?: null,
      newCloseFactorMantissa?: null,
    ): NewCloseFactorEventFilter;
    NewCloseFactor(oldCloseFactorMantissa?: null, newCloseFactorMantissa?: null): NewCloseFactorEventFilter;

    "NewCollateralFactor(address,uint256,uint256)"(
      fToken?: null,
      oldCollateralFactorMantissa?: null,
      newCollateralFactorMantissa?: null,
    ): NewCollateralFactorEventFilter;
    NewCollateralFactor(
      fToken?: null,
      oldCollateralFactorMantissa?: null,
      newCollateralFactorMantissa?: null,
    ): NewCollateralFactorEventFilter;

    "NewPendingAdmin(address,address)"(oldPendingAdmin?: null, newPendingAdmin?: null): NewPendingAdminEventFilter;
    NewPendingAdmin(oldPendingAdmin?: null, newPendingAdmin?: null): NewPendingAdminEventFilter;

    "NewPriceOracle(address,address)"(oldPriceOracle?: null, newPriceOracle?: null): NewPriceOracleEventFilter;
    NewPriceOracle(oldPriceOracle?: null, newPriceOracle?: null): NewPriceOracleEventFilter;
  };

  estimateGas: {
    IS_RISK_MANAGER(overrides?: CallOverrides): Promise<BigNumber>;

    _borrowGuardianPaused(overrides?: CallOverrides): Promise<BigNumber>;

    _supplyGuardianPaused(overrides?: CallOverrides): Promise<BigNumber>;

    acceptAdmin(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    admin(overrides?: CallOverrides): Promise<BigNumber>;

    borrowAllowed(
      _fToken: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    borrowGuardianPaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    checkListed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    checkMembership(
      _account: PromiseOrValue<string>,
      _fToken: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    closeFactorMantissa(overrides?: CallOverrides): Promise<BigNumber>;

    closeLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    collateralFactorBoost(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    enterMarkets(
      _fTokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exitMarket(
      _fToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getAccountLiquidity(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    getHypotheticalAccountLiquidity(
      _account: PromiseOrValue<string>,
      _fToken: PromiseOrValue<string>,
      _redeemToken: PromiseOrValue<BigNumberish>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getMarketsEntered(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      _priceOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    initiateLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isRiskManager(overrides?: CallOverrides): Promise<BigNumber>;

    liquidatableTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    liquidateBorrowAllowed(
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    liquidateCalculateDiscount(_borrower: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    liquidateCalculateSeizeTokens(
      _borrower: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    markets(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    marketsEntered(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    oracle(overrides?: CallOverrides): Promise<BigNumber>;

    pauseGuardian(overrides?: CallOverrides): Promise<BigNumber>;

    pendingAdmin(overrides?: CallOverrides): Promise<BigNumber>;

    redeemAllowed(
      _fToken: PromiseOrValue<string>,
      _redeemer: PromiseOrValue<string>,
      _redeemTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    repayBorrowAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    seizeAllowed(
      _fTokenCollateral: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _seizeTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    seizeGuardianPaused(overrides?: CallOverrides): Promise<BigNumber>;

    setBorrowPaused(
      _fToken: PromiseOrValue<string>,
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setCloseFactor(
      _newCloseFactorMantissa: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setCollateralFactor(
      _fToken: PromiseOrValue<string>,
      _newCollateralFactorMantissa: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPendingAdmin(
      _newPendingAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setPriceOracle(
      _newOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setSeizePaused(
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setSupplyPaused(
      _fToken: PromiseOrValue<string>,
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setTier(
      _fToken: PromiseOrValue<string>,
      _tier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setTransferPaused(
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setVeToken(
      _newVetoken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    supplyAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    supplyGuardianPaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    supportMarket(
      _fToken: PromiseOrValue<string>,
      _collateralFactorMantissa: PromiseOrValue<BigNumberish>,
      _tier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    transferAllowed(
      _fToken: PromiseOrValue<string>,
      _src: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    transferGuardianPaused(overrides?: CallOverrides): Promise<BigNumber>;

    veToken(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    IS_RISK_MANAGER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _borrowGuardianPaused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _supplyGuardianPaused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptAdmin(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    admin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    borrowAllowed(
      _fToken: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    borrowGuardianPaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    checkListed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    checkMembership(
      _account: PromiseOrValue<string>,
      _fToken: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    closeFactorMantissa(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    closeLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    collateralFactorBoost(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    enterMarkets(
      _fTokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exitMarket(
      _fToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getAccountLiquidity(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getHypotheticalAccountLiquidity(
      _account: PromiseOrValue<string>,
      _fToken: PromiseOrValue<string>,
      _redeemToken: PromiseOrValue<BigNumberish>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getMarketsEntered(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      _priceOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    initiateLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isRiskManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liquidatableTime(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liquidateBorrowAllowed(
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    liquidateCalculateDiscount(
      _borrower: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    liquidateCalculateSeizeTokens(
      _borrower: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    markets(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketsEntered(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    oracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pauseGuardian(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingAdmin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    redeemAllowed(
      _fToken: PromiseOrValue<string>,
      _redeemer: PromiseOrValue<string>,
      _redeemTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    repayBorrowAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    seizeAllowed(
      _fTokenCollateral: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _seizeTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    seizeGuardianPaused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setBorrowPaused(
      _fToken: PromiseOrValue<string>,
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setCloseFactor(
      _newCloseFactorMantissa: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setCollateralFactor(
      _fToken: PromiseOrValue<string>,
      _newCollateralFactorMantissa: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPendingAdmin(
      _newPendingAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setPriceOracle(
      _newOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setSeizePaused(
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setSupplyPaused(
      _fToken: PromiseOrValue<string>,
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setTier(
      _fToken: PromiseOrValue<string>,
      _tier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setTransferPaused(
      _state: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setVeToken(
      _newVetoken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    supplyAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supplyGuardianPaused(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportMarket(
      _fToken: PromiseOrValue<string>,
      _collateralFactorMantissa: PromiseOrValue<BigNumberish>,
      _tier: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    transferAllowed(
      _fToken: PromiseOrValue<string>,
      _src: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    transferGuardianPaused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    veToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
