/* Autogenerated file. Do not edit manually. */

/* tslint:disable */

/* eslint-disable */
import type { EventFragment, FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";

import type { OnEvent, PromiseOrValue, TypedEvent, TypedEventFilter, TypedListener } from "../../../common";

export interface IRiskManagerInterface extends utils.Interface {
  functions: {
    "borrowAllowed(address,address,uint256)": FunctionFragment;
    "checkListed(address)": FunctionFragment;
    "closeLiquidation(address)": FunctionFragment;
    "enterMarkets(address[])": FunctionFragment;
    "exitMarket(address)": FunctionFragment;
    "getMarketsEntered(address)": FunctionFragment;
    "initiateLiquidation(address)": FunctionFragment;
    "isRiskManager()": FunctionFragment;
    "liquidateBorrowAllowed(address,address,address,uint256)": FunctionFragment;
    "liquidateCalculateSeizeTokens(address,address,address,uint256)": FunctionFragment;
    "redeemAllowed(address,address,uint256)": FunctionFragment;
    "repayBorrowAllowed(address)": FunctionFragment;
    "seizeAllowed(address,address,address,uint256)": FunctionFragment;
    "supplyAllowed(address)": FunctionFragment;
    "transferAllowed(address,address,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "borrowAllowed"
      | "checkListed"
      | "closeLiquidation"
      | "enterMarkets"
      | "exitMarket"
      | "getMarketsEntered"
      | "initiateLiquidation"
      | "isRiskManager"
      | "liquidateBorrowAllowed"
      | "liquidateCalculateSeizeTokens"
      | "redeemAllowed"
      | "repayBorrowAllowed"
      | "seizeAllowed"
      | "supplyAllowed"
      | "transferAllowed",
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "borrowAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "checkListed", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "closeLiquidation", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "enterMarkets", values: [PromiseOrValue<string>[]]): string;
  encodeFunctionData(functionFragment: "exitMarket", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "getMarketsEntered", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "initiateLiquidation", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: "isRiskManager", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "liquidateBorrowAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: "liquidateCalculateSeizeTokens",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: "redeemAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "repayBorrowAllowed", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: "seizeAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(functionFragment: "supplyAllowed", values: [PromiseOrValue<string>]): string;
  encodeFunctionData(
    functionFragment: "transferAllowed",
    values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;

  decodeFunctionResult(functionFragment: "borrowAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "checkListed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "closeLiquidation", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "enterMarkets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "exitMarket", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMarketsEntered", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initiateLiquidation", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isRiskManager", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liquidateBorrowAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liquidateCalculateSeizeTokens", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "redeemAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "repayBorrowAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "seizeAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "supplyAllowed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "transferAllowed", data: BytesLike): Result;

  events: {
    "ActionPausedGlobal(string,bool)": EventFragment;
    "ActionPausedMarket(address,string,bool)": EventFragment;
    "MarketEntered(address,address)": EventFragment;
    "MarketExited(address,address)": EventFragment;
    "MarketListed(address)": EventFragment;
    "NewAdmin(address,address)": EventFragment;
    "NewCloseFactor(uint256,uint256)": EventFragment;
    "NewCollateralFactor(address,uint256,uint256)": EventFragment;
    "NewPendingAdmin(address,address)": EventFragment;
    "NewPriceOracle(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ActionPausedGlobal"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ActionPausedMarket"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarketEntered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarketExited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarketListed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewAdmin"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewCloseFactor"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewCollateralFactor"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewPendingAdmin"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewPriceOracle"): EventFragment;
}

export interface ActionPausedGlobalEventObject {
  action: string;
  pauseState: boolean;
}
export type ActionPausedGlobalEvent = TypedEvent<[string, boolean], ActionPausedGlobalEventObject>;

export type ActionPausedGlobalEventFilter = TypedEventFilter<ActionPausedGlobalEvent>;

export interface ActionPausedMarketEventObject {
  fToken: string;
  action: string;
  pauseState: boolean;
}
export type ActionPausedMarketEvent = TypedEvent<[string, string, boolean], ActionPausedMarketEventObject>;

export type ActionPausedMarketEventFilter = TypedEventFilter<ActionPausedMarketEvent>;

export interface MarketEnteredEventObject {
  fToken: string;
  account: string;
}
export type MarketEnteredEvent = TypedEvent<[string, string], MarketEnteredEventObject>;

export type MarketEnteredEventFilter = TypedEventFilter<MarketEnteredEvent>;

export interface MarketExitedEventObject {
  fToken: string;
  account: string;
}
export type MarketExitedEvent = TypedEvent<[string, string], MarketExitedEventObject>;

export type MarketExitedEventFilter = TypedEventFilter<MarketExitedEvent>;

export interface MarketListedEventObject {
  fToken: string;
}
export type MarketListedEvent = TypedEvent<[string], MarketListedEventObject>;

export type MarketListedEventFilter = TypedEventFilter<MarketListedEvent>;

export interface NewAdminEventObject {
  oldAdmin: string;
  newAdmin: string;
}
export type NewAdminEvent = TypedEvent<[string, string], NewAdminEventObject>;

export type NewAdminEventFilter = TypedEventFilter<NewAdminEvent>;

export interface NewCloseFactorEventObject {
  oldCloseFactorMantissa: BigNumber;
  newCloseFactorMantissa: BigNumber;
}
export type NewCloseFactorEvent = TypedEvent<[BigNumber, BigNumber], NewCloseFactorEventObject>;

export type NewCloseFactorEventFilter = TypedEventFilter<NewCloseFactorEvent>;

export interface NewCollateralFactorEventObject {
  fToken: string;
  oldCollateralFactorMantissa: BigNumber;
  newCollateralFactorMantissa: BigNumber;
}
export type NewCollateralFactorEvent = TypedEvent<[string, BigNumber, BigNumber], NewCollateralFactorEventObject>;

export type NewCollateralFactorEventFilter = TypedEventFilter<NewCollateralFactorEvent>;

export interface NewPendingAdminEventObject {
  oldPendingAdmin: string;
  newPendingAdmin: string;
}
export type NewPendingAdminEvent = TypedEvent<[string, string], NewPendingAdminEventObject>;

export type NewPendingAdminEventFilter = TypedEventFilter<NewPendingAdminEvent>;

export interface NewPriceOracleEventObject {
  oldPriceOracle: string;
  newPriceOracle: string;
}
export type NewPriceOracleEvent = TypedEvent<[string, string], NewPriceOracleEventObject>;

export type NewPriceOracleEventFilter = TypedEventFilter<NewPriceOracleEvent>;

export interface IRiskManager extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IRiskManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    borrowAllowed(
      _fToken: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    checkListed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    closeLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    enterMarkets(
      _fTokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    exitMarket(
      _fToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getMarketsEntered(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[string[]]>;

    initiateLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    isRiskManager(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    liquidateBorrowAllowed(
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    liquidateCalculateSeizeTokens(
      _borrower: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { seizeTokens: BigNumber; repayValue: BigNumber }>;

    redeemAllowed(
      _fToken: PromiseOrValue<string>,
      _redeemer: PromiseOrValue<string>,
      _redeemTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    repayBorrowAllowed(
      _fToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    seizeAllowed(
      _fTokenCollateral: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _seizeTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean, boolean] & { allowed: boolean; isCollateralTier: boolean }>;

    supplyAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    transferAllowed(
      _fToken: PromiseOrValue<string>,
      _src: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;
  };

  borrowAllowed(
    _fToken: PromiseOrValue<string>,
    _borrower: PromiseOrValue<string>,
    _borrowAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  checkListed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  closeLiquidation(
    _account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  enterMarkets(
    _fTokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  exitMarket(
    _fToken: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getMarketsEntered(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

  initiateLiquidation(
    _account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  isRiskManager(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  liquidateBorrowAllowed(
    _fTokenBorrowed: PromiseOrValue<string>,
    _fTokenCollateral: PromiseOrValue<string>,
    _borrower: PromiseOrValue<string>,
    _repayAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  liquidateCalculateSeizeTokens(
    _borrower: PromiseOrValue<string>,
    _fTokenBorrowed: PromiseOrValue<string>,
    _fTokenCollateral: PromiseOrValue<string>,
    _repayAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { seizeTokens: BigNumber; repayValue: BigNumber }>;

  redeemAllowed(
    _fToken: PromiseOrValue<string>,
    _redeemer: PromiseOrValue<string>,
    _redeemTokens: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  repayBorrowAllowed(
    _fToken: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  seizeAllowed(
    _fTokenCollateral: PromiseOrValue<string>,
    _fTokenBorrowed: PromiseOrValue<string>,
    _borrower: PromiseOrValue<string>,
    _seizeTokens: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<[boolean, boolean] & { allowed: boolean; isCollateralTier: boolean }>;

  supplyAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  transferAllowed(
    _fToken: PromiseOrValue<string>,
    _src: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  callStatic: {
    borrowAllowed(
      _fToken: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    checkListed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    closeLiquidation(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    enterMarkets(_fTokens: PromiseOrValue<string>[], overrides?: CallOverrides): Promise<void>;

    exitMarket(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    getMarketsEntered(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<string[]>;

    initiateLiquidation(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    isRiskManager(overrides?: CallOverrides): Promise<boolean>;

    liquidateBorrowAllowed(
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    liquidateCalculateSeizeTokens(
      _borrower: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { seizeTokens: BigNumber; repayValue: BigNumber }>;

    redeemAllowed(
      _fToken: PromiseOrValue<string>,
      _redeemer: PromiseOrValue<string>,
      _redeemTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    repayBorrowAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    seizeAllowed(
      _fTokenCollateral: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _seizeTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<[boolean, boolean] & { allowed: boolean; isCollateralTier: boolean }>;

    supplyAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    transferAllowed(
      _fToken: PromiseOrValue<string>,
      _src: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<boolean>;
  };

  filters: {
    "ActionPausedGlobal(string,bool)"(action?: null, pauseState?: null): ActionPausedGlobalEventFilter;
    ActionPausedGlobal(action?: null, pauseState?: null): ActionPausedGlobalEventFilter;

    "ActionPausedMarket(address,string,bool)"(
      fToken?: null,
      action?: null,
      pauseState?: null,
    ): ActionPausedMarketEventFilter;
    ActionPausedMarket(fToken?: null, action?: null, pauseState?: null): ActionPausedMarketEventFilter;

    "MarketEntered(address,address)"(fToken?: null, account?: null): MarketEnteredEventFilter;
    MarketEntered(fToken?: null, account?: null): MarketEnteredEventFilter;

    "MarketExited(address,address)"(fToken?: null, account?: null): MarketExitedEventFilter;
    MarketExited(fToken?: null, account?: null): MarketExitedEventFilter;

    "MarketListed(address)"(fToken?: null): MarketListedEventFilter;
    MarketListed(fToken?: null): MarketListedEventFilter;

    "NewAdmin(address,address)"(oldAdmin?: null, newAdmin?: null): NewAdminEventFilter;
    NewAdmin(oldAdmin?: null, newAdmin?: null): NewAdminEventFilter;

    "NewCloseFactor(uint256,uint256)"(
      oldCloseFactorMantissa?: null,
      newCloseFactorMantissa?: null,
    ): NewCloseFactorEventFilter;
    NewCloseFactor(oldCloseFactorMantissa?: null, newCloseFactorMantissa?: null): NewCloseFactorEventFilter;

    "NewCollateralFactor(address,uint256,uint256)"(
      fToken?: null,
      oldCollateralFactorMantissa?: null,
      newCollateralFactorMantissa?: null,
    ): NewCollateralFactorEventFilter;
    NewCollateralFactor(
      fToken?: null,
      oldCollateralFactorMantissa?: null,
      newCollateralFactorMantissa?: null,
    ): NewCollateralFactorEventFilter;

    "NewPendingAdmin(address,address)"(oldPendingAdmin?: null, newPendingAdmin?: null): NewPendingAdminEventFilter;
    NewPendingAdmin(oldPendingAdmin?: null, newPendingAdmin?: null): NewPendingAdminEventFilter;

    "NewPriceOracle(address,address)"(oldPriceOracle?: null, newPriceOracle?: null): NewPriceOracleEventFilter;
    NewPriceOracle(oldPriceOracle?: null, newPriceOracle?: null): NewPriceOracleEventFilter;
  };

  estimateGas: {
    borrowAllowed(
      _fToken: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    checkListed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    closeLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    enterMarkets(
      _fTokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    exitMarket(
      _fToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getMarketsEntered(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    initiateLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    isRiskManager(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    liquidateBorrowAllowed(
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    liquidateCalculateSeizeTokens(
      _borrower: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    redeemAllowed(
      _fToken: PromiseOrValue<string>,
      _redeemer: PromiseOrValue<string>,
      _redeemTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    repayBorrowAllowed(
      _fToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    seizeAllowed(
      _fTokenCollateral: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _seizeTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    supplyAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    transferAllowed(
      _fToken: PromiseOrValue<string>,
      _src: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    borrowAllowed(
      _fToken: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _borrowAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    checkListed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    closeLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    enterMarkets(
      _fTokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    exitMarket(
      _fToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getMarketsEntered(_account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initiateLiquidation(
      _account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    isRiskManager(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    liquidateBorrowAllowed(
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    liquidateCalculateSeizeTokens(
      _borrower: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _fTokenCollateral: PromiseOrValue<string>,
      _repayAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    redeemAllowed(
      _fToken: PromiseOrValue<string>,
      _redeemer: PromiseOrValue<string>,
      _redeemTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    repayBorrowAllowed(
      _fToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    seizeAllowed(
      _fTokenCollateral: PromiseOrValue<string>,
      _fTokenBorrowed: PromiseOrValue<string>,
      _borrower: PromiseOrValue<string>,
      _seizeTokens: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    supplyAllowed(_fToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferAllowed(
      _fToken: PromiseOrValue<string>,
      _src: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;
  };
}
